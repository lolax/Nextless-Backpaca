// Code generated by Prisma (prisma@1.24.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  country: (where?: CountryWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  visit: (where?: VisitWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  country: (where: CountryWhereUniqueInput) => CountryPromise;
  countries: (
    args?: {
      where?: CountryWhereInput;
      orderBy?: CountryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Country>;
  countriesConnection: (
    args?: {
      where?: CountryWhereInput;
      orderBy?: CountryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CountryConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  visit: (where: VisitWhereUniqueInput) => VisitPromise;
  visits: (
    args?: {
      where?: VisitWhereInput;
      orderBy?: VisitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Visit>;
  visitsConnection: (
    args?: {
      where?: VisitWhereInput;
      orderBy?: VisitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VisitConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCountry: (data: CountryCreateInput) => CountryPromise;
  updateCountry: (
    args: { data: CountryUpdateInput; where: CountryWhereUniqueInput }
  ) => CountryPromise;
  updateManyCountries: (
    args: { data: CountryUpdateManyMutationInput; where?: CountryWhereInput }
  ) => BatchPayloadPromise;
  upsertCountry: (
    args: {
      where: CountryWhereUniqueInput;
      create: CountryCreateInput;
      update: CountryUpdateInput;
    }
  ) => CountryPromise;
  deleteCountry: (where: CountryWhereUniqueInput) => CountryPromise;
  deleteManyCountries: (where?: CountryWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVisit: (data: VisitCreateInput) => VisitPromise;
  updateVisit: (
    args: { data: VisitUpdateInput; where: VisitWhereUniqueInput }
  ) => VisitPromise;
  updateManyVisits: (
    args: { data: VisitUpdateManyMutationInput; where?: VisitWhereInput }
  ) => BatchPayloadPromise;
  upsertVisit: (
    args: {
      where: VisitWhereUniqueInput;
      create: VisitCreateInput;
      update: VisitUpdateInput;
    }
  ) => VisitPromise;
  deleteVisit: (where: VisitWhereUniqueInput) => VisitPromise;
  deleteManyVisits: (where?: VisitWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  country: (
    where?: CountrySubscriptionWhereInput
  ) => CountrySubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  visit: (
    where?: VisitSubscriptionWhereInput
  ) => VisitSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type VisitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "note_ASC"
  | "note_DESC"
  | "level_ASC"
  | "level_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "auth0id_ASC"
  | "auth0id_DESC"
  | "identity_ASC"
  | "identity_DESC"
  | "name_ASC"
  | "name_DESC"
  | "nickname_ASC"
  | "nickname_DESC"
  | "email_ASC"
  | "email_DESC"
  | "twitterHandle_ASC"
  | "twitterHandle_DESC"
  | "scratchingAutomated_ASC"
  | "scratchingAutomated_DESC"
  | "isPrivate_ASC"
  | "isPrivate_DESC"
  | "isPremium_ASC"
  | "isPremium_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "pictureUrl_ASC"
  | "pictureUrl_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CountryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface VisitUpdateWithWhereUniqueWithoutCountryInput {
  where: VisitWhereUniqueInput;
  data: VisitUpdateWithoutCountryDataInput;
}

export type CountryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface VisitUpdateManyDataInput {
  note?: String;
  level?: Int;
}

export interface UserCreateInput {
  auth0id?: String;
  identity?: String;
  name?: String;
  nickname?: String;
  email?: String;
  twitterHandle?: String;
  scratchingAutomated?: Boolean;
  isPrivate?: Boolean;
  visits?: VisitCreateManyWithoutUserInput;
  friends?: UserCreateManyInput;
  isPremium?: Boolean;
  bio?: String;
  pictureUrl?: String;
}

export interface UserUpdateWithoutVisitsDataInput {
  auth0id?: String;
  identity?: String;
  name?: String;
  nickname?: String;
  email?: String;
  twitterHandle?: String;
  scratchingAutomated?: Boolean;
  isPrivate?: Boolean;
  friends?: UserUpdateManyInput;
  isPremium?: Boolean;
  bio?: String;
  pictureUrl?: String;
}

export interface VisitCreateManyWithoutUserInput {
  create?: VisitCreateWithoutUserInput[] | VisitCreateWithoutUserInput;
  connect?: VisitWhereUniqueInput[] | VisitWhereUniqueInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  auth0id?: String;
  auth0id_not?: String;
  auth0id_in?: String[] | String;
  auth0id_not_in?: String[] | String;
  auth0id_lt?: String;
  auth0id_lte?: String;
  auth0id_gt?: String;
  auth0id_gte?: String;
  auth0id_contains?: String;
  auth0id_not_contains?: String;
  auth0id_starts_with?: String;
  auth0id_not_starts_with?: String;
  auth0id_ends_with?: String;
  auth0id_not_ends_with?: String;
  identity?: String;
  identity_not?: String;
  identity_in?: String[] | String;
  identity_not_in?: String[] | String;
  identity_lt?: String;
  identity_lte?: String;
  identity_gt?: String;
  identity_gte?: String;
  identity_contains?: String;
  identity_not_contains?: String;
  identity_starts_with?: String;
  identity_not_starts_with?: String;
  identity_ends_with?: String;
  identity_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  nickname?: String;
  nickname_not?: String;
  nickname_in?: String[] | String;
  nickname_not_in?: String[] | String;
  nickname_lt?: String;
  nickname_lte?: String;
  nickname_gt?: String;
  nickname_gte?: String;
  nickname_contains?: String;
  nickname_not_contains?: String;
  nickname_starts_with?: String;
  nickname_not_starts_with?: String;
  nickname_ends_with?: String;
  nickname_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  twitterHandle?: String;
  twitterHandle_not?: String;
  twitterHandle_in?: String[] | String;
  twitterHandle_not_in?: String[] | String;
  twitterHandle_lt?: String;
  twitterHandle_lte?: String;
  twitterHandle_gt?: String;
  twitterHandle_gte?: String;
  twitterHandle_contains?: String;
  twitterHandle_not_contains?: String;
  twitterHandle_starts_with?: String;
  twitterHandle_not_starts_with?: String;
  twitterHandle_ends_with?: String;
  twitterHandle_not_ends_with?: String;
  scratchingAutomated?: Boolean;
  scratchingAutomated_not?: Boolean;
  isPrivate?: Boolean;
  isPrivate_not?: Boolean;
  visits_every?: VisitWhereInput;
  visits_some?: VisitWhereInput;
  visits_none?: VisitWhereInput;
  friends_every?: UserWhereInput;
  friends_some?: UserWhereInput;
  friends_none?: UserWhereInput;
  isPremium?: Boolean;
  isPremium_not?: Boolean;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  pictureUrl?: String;
  pictureUrl_not?: String;
  pictureUrl_in?: String[] | String;
  pictureUrl_not_in?: String[] | String;
  pictureUrl_lt?: String;
  pictureUrl_lte?: String;
  pictureUrl_gt?: String;
  pictureUrl_gte?: String;
  pictureUrl_contains?: String;
  pictureUrl_not_contains?: String;
  pictureUrl_starts_with?: String;
  pictureUrl_not_starts_with?: String;
  pictureUrl_ends_with?: String;
  pictureUrl_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface VisitCreateWithoutUserInput {
  country: CountryCreateOneWithoutVisitsInput;
  note?: String;
  level?: Int;
}

export interface CountrySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CountryWhereInput;
  AND?: CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput;
  OR?: CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput;
  NOT?: CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput;
}

export interface CountryCreateOneWithoutVisitsInput {
  create?: CountryCreateWithoutVisitsInput;
  connect?: CountryWhereUniqueInput;
}

export interface VisitUpdateManyMutationInput {
  note?: String;
  level?: Int;
}

export interface CountryCreateWithoutVisitsInput {
  name: String;
  code: String;
}

export interface VisitCreateInput {
  user: UserCreateOneWithoutVisitsInput;
  country: CountryCreateOneWithoutVisitsInput;
  note?: String;
  level?: Int;
}

export interface CountryUpdateInput {
  name?: String;
  code?: String;
  visits?: VisitUpdateManyWithoutCountryInput;
}

export interface UserUpdateInput {
  auth0id?: String;
  identity?: String;
  name?: String;
  nickname?: String;
  email?: String;
  twitterHandle?: String;
  scratchingAutomated?: Boolean;
  isPrivate?: Boolean;
  visits?: VisitUpdateManyWithoutUserInput;
  friends?: UserUpdateManyInput;
  isPremium?: Boolean;
  bio?: String;
  pictureUrl?: String;
}

export interface VisitUpdateManyWithoutCountryInput {
  create?: VisitCreateWithoutCountryInput[] | VisitCreateWithoutCountryInput;
  delete?: VisitWhereUniqueInput[] | VisitWhereUniqueInput;
  connect?: VisitWhereUniqueInput[] | VisitWhereUniqueInput;
  disconnect?: VisitWhereUniqueInput[] | VisitWhereUniqueInput;
  update?:
    | VisitUpdateWithWhereUniqueWithoutCountryInput[]
    | VisitUpdateWithWhereUniqueWithoutCountryInput;
  upsert?:
    | VisitUpsertWithWhereUniqueWithoutCountryInput[]
    | VisitUpsertWithWhereUniqueWithoutCountryInput;
  deleteMany?: VisitScalarWhereInput[] | VisitScalarWhereInput;
  updateMany?:
    | VisitUpdateManyWithWhereNestedInput[]
    | VisitUpdateManyWithWhereNestedInput;
}

export interface CountryUpdateManyMutationInput {
  name?: String;
  code?: String;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserUpsertWithoutVisitsInput {
  update: UserUpdateWithoutVisitsDataInput;
  create: UserCreateWithoutVisitsInput;
}

export interface VisitUpdateWithoutCountryDataInput {
  user?: UserUpdateOneRequiredWithoutVisitsInput;
  note?: String;
  level?: Int;
}

export interface UserUpdateManyDataInput {
  auth0id?: String;
  identity?: String;
  name?: String;
  nickname?: String;
  email?: String;
  twitterHandle?: String;
  scratchingAutomated?: Boolean;
  isPrivate?: Boolean;
  isPremium?: Boolean;
  bio?: String;
  pictureUrl?: String;
}

export interface UserUpdateOneRequiredWithoutVisitsInput {
  create?: UserCreateWithoutVisitsInput;
  update?: UserUpdateWithoutVisitsDataInput;
  upsert?: UserUpsertWithoutVisitsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  auth0id?: String;
  auth0id_not?: String;
  auth0id_in?: String[] | String;
  auth0id_not_in?: String[] | String;
  auth0id_lt?: String;
  auth0id_lte?: String;
  auth0id_gt?: String;
  auth0id_gte?: String;
  auth0id_contains?: String;
  auth0id_not_contains?: String;
  auth0id_starts_with?: String;
  auth0id_not_starts_with?: String;
  auth0id_ends_with?: String;
  auth0id_not_ends_with?: String;
  identity?: String;
  identity_not?: String;
  identity_in?: String[] | String;
  identity_not_in?: String[] | String;
  identity_lt?: String;
  identity_lte?: String;
  identity_gt?: String;
  identity_gte?: String;
  identity_contains?: String;
  identity_not_contains?: String;
  identity_starts_with?: String;
  identity_not_starts_with?: String;
  identity_ends_with?: String;
  identity_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  nickname?: String;
  nickname_not?: String;
  nickname_in?: String[] | String;
  nickname_not_in?: String[] | String;
  nickname_lt?: String;
  nickname_lte?: String;
  nickname_gt?: String;
  nickname_gte?: String;
  nickname_contains?: String;
  nickname_not_contains?: String;
  nickname_starts_with?: String;
  nickname_not_starts_with?: String;
  nickname_ends_with?: String;
  nickname_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  twitterHandle?: String;
  twitterHandle_not?: String;
  twitterHandle_in?: String[] | String;
  twitterHandle_not_in?: String[] | String;
  twitterHandle_lt?: String;
  twitterHandle_lte?: String;
  twitterHandle_gt?: String;
  twitterHandle_gte?: String;
  twitterHandle_contains?: String;
  twitterHandle_not_contains?: String;
  twitterHandle_starts_with?: String;
  twitterHandle_not_starts_with?: String;
  twitterHandle_ends_with?: String;
  twitterHandle_not_ends_with?: String;
  scratchingAutomated?: Boolean;
  scratchingAutomated_not?: Boolean;
  isPrivate?: Boolean;
  isPrivate_not?: Boolean;
  isPremium?: Boolean;
  isPremium_not?: Boolean;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  pictureUrl?: String;
  pictureUrl_not?: String;
  pictureUrl_in?: String[] | String;
  pictureUrl_not_in?: String[] | String;
  pictureUrl_lt?: String;
  pictureUrl_lte?: String;
  pictureUrl_gt?: String;
  pictureUrl_gte?: String;
  pictureUrl_contains?: String;
  pictureUrl_not_contains?: String;
  pictureUrl_starts_with?: String;
  pictureUrl_not_starts_with?: String;
  pictureUrl_ends_with?: String;
  pictureUrl_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface CountryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  visits_every?: VisitWhereInput;
  visits_some?: VisitWhereInput;
  visits_none?: VisitWhereInput;
  AND?: CountryWhereInput[] | CountryWhereInput;
  OR?: CountryWhereInput[] | CountryWhereInput;
  NOT?: CountryWhereInput[] | CountryWhereInput;
}

export interface CountryCreateInput {
  name: String;
  code: String;
  visits?: VisitCreateManyWithoutCountryInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface VisitCreateWithoutCountryInput {
  user: UserCreateOneWithoutVisitsInput;
  note?: String;
  level?: Int;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserCreateWithoutVisitsInput {
  auth0id?: String;
  identity?: String;
  name?: String;
  nickname?: String;
  email?: String;
  twitterHandle?: String;
  scratchingAutomated?: Boolean;
  isPrivate?: Boolean;
  friends?: UserCreateManyInput;
  isPremium?: Boolean;
  bio?: String;
  pictureUrl?: String;
}

export interface UserUpdateDataInput {
  auth0id?: String;
  identity?: String;
  name?: String;
  nickname?: String;
  email?: String;
  twitterHandle?: String;
  scratchingAutomated?: Boolean;
  isPrivate?: Boolean;
  visits?: VisitUpdateManyWithoutUserInput;
  friends?: UserUpdateManyInput;
  isPremium?: Boolean;
  bio?: String;
  pictureUrl?: String;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface VisitUpdateManyWithoutUserInput {
  create?: VisitCreateWithoutUserInput[] | VisitCreateWithoutUserInput;
  delete?: VisitWhereUniqueInput[] | VisitWhereUniqueInput;
  connect?: VisitWhereUniqueInput[] | VisitWhereUniqueInput;
  disconnect?: VisitWhereUniqueInput[] | VisitWhereUniqueInput;
  update?:
    | VisitUpdateWithWhereUniqueWithoutUserInput[]
    | VisitUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | VisitUpsertWithWhereUniqueWithoutUserInput[]
    | VisitUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: VisitScalarWhereInput[] | VisitScalarWhereInput;
  updateMany?:
    | VisitUpdateManyWithWhereNestedInput[]
    | VisitUpdateManyWithWhereNestedInput;
}

export interface VisitUpdateInput {
  user?: UserUpdateOneRequiredWithoutVisitsInput;
  country?: CountryUpdateOneRequiredWithoutVisitsInput;
  note?: String;
  level?: Int;
}

export interface VisitUpdateWithWhereUniqueWithoutUserInput {
  where: VisitWhereUniqueInput;
  data: VisitUpdateWithoutUserDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  auth0id?: String;
  twitterHandle?: String;
}>;

export interface VisitUpdateWithoutUserDataInput {
  country?: CountryUpdateOneRequiredWithoutVisitsInput;
  note?: String;
  level?: Int;
}

export type VisitWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CountryUpdateOneRequiredWithoutVisitsInput {
  create?: CountryCreateWithoutVisitsInput;
  update?: CountryUpdateWithoutVisitsDataInput;
  upsert?: CountryUpsertWithoutVisitsInput;
  connect?: CountryWhereUniqueInput;
}

export interface UserCreateOneWithoutVisitsInput {
  create?: UserCreateWithoutVisitsInput;
  connect?: UserWhereUniqueInput;
}

export interface CountryUpdateWithoutVisitsDataInput {
  name?: String;
  code?: String;
}

export interface VisitWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  country?: CountryWhereInput;
  note?: String;
  note_not?: String;
  note_in?: String[] | String;
  note_not_in?: String[] | String;
  note_lt?: String;
  note_lte?: String;
  note_gt?: String;
  note_gte?: String;
  note_contains?: String;
  note_not_contains?: String;
  note_starts_with?: String;
  note_not_starts_with?: String;
  note_ends_with?: String;
  note_not_ends_with?: String;
  level?: Int;
  level_not?: Int;
  level_in?: Int[] | Int;
  level_not_in?: Int[] | Int;
  level_lt?: Int;
  level_lte?: Int;
  level_gt?: Int;
  level_gte?: Int;
  AND?: VisitWhereInput[] | VisitWhereInput;
  OR?: VisitWhereInput[] | VisitWhereInput;
  NOT?: VisitWhereInput[] | VisitWhereInput;
}

export interface VisitUpdateManyWithWhereNestedInput {
  where: VisitScalarWhereInput;
  data: VisitUpdateManyDataInput;
}

export interface VisitScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  note?: String;
  note_not?: String;
  note_in?: String[] | String;
  note_not_in?: String[] | String;
  note_lt?: String;
  note_lte?: String;
  note_gt?: String;
  note_gte?: String;
  note_contains?: String;
  note_not_contains?: String;
  note_starts_with?: String;
  note_not_starts_with?: String;
  note_ends_with?: String;
  note_not_ends_with?: String;
  level?: Int;
  level_not?: Int;
  level_in?: Int[] | Int;
  level_not_in?: Int[] | Int;
  level_lt?: Int;
  level_lte?: Int;
  level_gt?: Int;
  level_gte?: Int;
  AND?: VisitScalarWhereInput[] | VisitScalarWhereInput;
  OR?: VisitScalarWhereInput[] | VisitScalarWhereInput;
  NOT?: VisitScalarWhereInput[] | VisitScalarWhereInput;
}

export interface VisitUpsertWithWhereUniqueWithoutUserInput {
  where: VisitWhereUniqueInput;
  update: VisitUpdateWithoutUserDataInput;
  create: VisitCreateWithoutUserInput;
}

export interface CountryUpsertWithoutVisitsInput {
  update: CountryUpdateWithoutVisitsDataInput;
  create: CountryCreateWithoutVisitsInput;
}

export interface UserUpdateManyMutationInput {
  auth0id?: String;
  identity?: String;
  name?: String;
  nickname?: String;
  email?: String;
  twitterHandle?: String;
  scratchingAutomated?: Boolean;
  isPrivate?: Boolean;
  isPremium?: Boolean;
  bio?: String;
  pictureUrl?: String;
}

export interface VisitSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VisitWhereInput;
  AND?: VisitSubscriptionWhereInput[] | VisitSubscriptionWhereInput;
  OR?: VisitSubscriptionWhereInput[] | VisitSubscriptionWhereInput;
  NOT?: VisitSubscriptionWhereInput[] | VisitSubscriptionWhereInput;
}

export interface VisitCreateManyWithoutCountryInput {
  create?: VisitCreateWithoutCountryInput[] | VisitCreateWithoutCountryInput;
  connect?: VisitWhereUniqueInput[] | VisitWhereUniqueInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface VisitUpsertWithWhereUniqueWithoutCountryInput {
  where: VisitWhereUniqueInput;
  update: VisitUpdateWithoutCountryDataInput;
  create: VisitCreateWithoutCountryInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VisitPreviousValues {
  id: ID_Output;
  note?: String;
  level?: Int;
}

export interface VisitPreviousValuesPromise
  extends Promise<VisitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  note: () => Promise<String>;
  level: () => Promise<Int>;
}

export interface VisitPreviousValuesSubscription
  extends Promise<AsyncIterator<VisitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  note: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<Int>>;
}

export interface CountryEdge {
  node: Country;
  cursor: String;
}

export interface CountryEdgePromise extends Promise<CountryEdge>, Fragmentable {
  node: <T = CountryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CountryEdgeSubscription
  extends Promise<AsyncIterator<CountryEdge>>,
    Fragmentable {
  node: <T = CountrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CountryConnection {
  pageInfo: PageInfo;
  edges: CountryEdge[];
}

export interface CountryConnectionPromise
  extends Promise<CountryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CountryEdge>>() => T;
  aggregate: <T = AggregateCountryPromise>() => T;
}

export interface CountryConnectionSubscription
  extends Promise<AsyncIterator<CountryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CountryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCountrySubscription>() => T;
}

export interface AggregateVisit {
  count: Int;
}

export interface AggregateVisitPromise
  extends Promise<AggregateVisit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVisitSubscription
  extends Promise<AsyncIterator<AggregateVisit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VisitConnection {
  pageInfo: PageInfo;
  edges: VisitEdge[];
}

export interface VisitConnectionPromise
  extends Promise<VisitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VisitEdge>>() => T;
  aggregate: <T = AggregateVisitPromise>() => T;
}

export interface VisitConnectionSubscription
  extends Promise<AsyncIterator<VisitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VisitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVisitSubscription>() => T;
}

export interface Country {
  id: ID_Output;
  name: String;
  code: String;
}

export interface CountryPromise extends Promise<Country>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  visits: <T = FragmentableArray<Visit>>(
    args?: {
      where?: VisitWhereInput;
      orderBy?: VisitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CountrySubscription
  extends Promise<AsyncIterator<Country>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  visits: <T = Promise<AsyncIterator<VisitSubscription>>>(
    args?: {
      where?: VisitWhereInput;
      orderBy?: VisitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  auth0id?: String;
  identity?: String;
  name?: String;
  nickname?: String;
  email?: String;
  twitterHandle?: String;
  scratchingAutomated?: Boolean;
  isPrivate?: Boolean;
  isPremium?: Boolean;
  bio?: String;
  pictureUrl?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  auth0id: () => Promise<String>;
  identity: () => Promise<String>;
  name: () => Promise<String>;
  nickname: () => Promise<String>;
  email: () => Promise<String>;
  twitterHandle: () => Promise<String>;
  scratchingAutomated: () => Promise<Boolean>;
  isPrivate: () => Promise<Boolean>;
  visits: <T = FragmentableArray<Visit>>(
    args?: {
      where?: VisitWhereInput;
      orderBy?: VisitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  friends: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isPremium: () => Promise<Boolean>;
  bio: () => Promise<String>;
  pictureUrl: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  auth0id: () => Promise<AsyncIterator<String>>;
  identity: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  twitterHandle: () => Promise<AsyncIterator<String>>;
  scratchingAutomated: () => Promise<AsyncIterator<Boolean>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
  visits: <T = Promise<AsyncIterator<VisitSubscription>>>(
    args?: {
      where?: VisitWhereInput;
      orderBy?: VisitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  friends: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isPremium: () => Promise<AsyncIterator<Boolean>>;
  bio: () => Promise<AsyncIterator<String>>;
  pictureUrl: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateCountry {
  count: Int;
}

export interface AggregateCountryPromise
  extends Promise<AggregateCountry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCountrySubscription
  extends Promise<AsyncIterator<AggregateCountry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Visit {
  id: ID_Output;
  note?: String;
  level?: Int;
}

export interface VisitPromise extends Promise<Visit>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  country: <T = CountryPromise>() => T;
  note: () => Promise<String>;
  level: () => Promise<Int>;
}

export interface VisitSubscription
  extends Promise<AsyncIterator<Visit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  country: <T = CountrySubscription>() => T;
  note: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<Int>>;
}

export interface CountryPreviousValues {
  id: ID_Output;
  name: String;
  code: String;
}

export interface CountryPreviousValuesPromise
  extends Promise<CountryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
}

export interface CountryPreviousValuesSubscription
  extends Promise<AsyncIterator<CountryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface CountrySubscriptionPayload {
  mutation: MutationType;
  node: Country;
  updatedFields: String[];
  previousValues: CountryPreviousValues;
}

export interface CountrySubscriptionPayloadPromise
  extends Promise<CountrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CountryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CountryPreviousValuesPromise>() => T;
}

export interface CountrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CountrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CountrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CountryPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  auth0id?: String;
  identity?: String;
  name?: String;
  nickname?: String;
  email?: String;
  twitterHandle?: String;
  scratchingAutomated?: Boolean;
  isPrivate?: Boolean;
  isPremium?: Boolean;
  bio?: String;
  pictureUrl?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  auth0id: () => Promise<String>;
  identity: () => Promise<String>;
  name: () => Promise<String>;
  nickname: () => Promise<String>;
  email: () => Promise<String>;
  twitterHandle: () => Promise<String>;
  scratchingAutomated: () => Promise<Boolean>;
  isPrivate: () => Promise<Boolean>;
  isPremium: () => Promise<Boolean>;
  bio: () => Promise<String>;
  pictureUrl: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  auth0id: () => Promise<AsyncIterator<String>>;
  identity: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  twitterHandle: () => Promise<AsyncIterator<String>>;
  scratchingAutomated: () => Promise<AsyncIterator<Boolean>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
  isPremium: () => Promise<AsyncIterator<Boolean>>;
  bio: () => Promise<AsyncIterator<String>>;
  pictureUrl: () => Promise<AsyncIterator<String>>;
}

export interface VisitEdge {
  node: Visit;
  cursor: String;
}

export interface VisitEdgePromise extends Promise<VisitEdge>, Fragmentable {
  node: <T = VisitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VisitEdgeSubscription
  extends Promise<AsyncIterator<VisitEdge>>,
    Fragmentable {
  node: <T = VisitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VisitSubscriptionPayload {
  mutation: MutationType;
  node: Visit;
  updatedFields: String[];
  previousValues: VisitPreviousValues;
}

export interface VisitSubscriptionPayloadPromise
  extends Promise<VisitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VisitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VisitPreviousValuesPromise>() => T;
}

export interface VisitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VisitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VisitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VisitPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Country",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Visit",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
